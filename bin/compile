#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir> <env-path>

# fail fast
set -eo pipefail

# parse args
BIN_DIR=$(cd $(dirname $0); pwd) # absolute path
BUILDPACK_DIR=$(cd $(dirname $0); cd ..; pwd)
BUILD_DIR=$1
CACHE_DIR=$2
ENV_DIR=$3

source $BIN_DIR/utils

APP_DIR="/app"
TMP_APP_DIR=$CACHE_DIR/tmp_app_dir
CACHED_DIRS=".heroku"

# declare variables
DEFAULT_R_VERSION=4.0.1
R_VERSION="$DEFAULT_R_VERSION"
R_MAJOR_VERSION="${R_VERSION%%.*}"
CRAN_MIRROR=${CRAN_MIRROR:-"https://cloud.r-project.org"}
R_BINARIES="http://storage.googleapis.com/dashr/heroku-18/R-${R_VERSION}-nochroot.tar.xz"
#GCC_VERSION="$(gcc --version | grep ^gcc | sed 's/^.* //g')"
GCC_VERSION=7.5.0
START_TIME="$(date -u +%s)"

echo -n "-----> Fetching R $R_VERSION tarball...."
echo
curl --progress-bar $R_BINARIES | xz --decompress - > "$(basename ${R_BINARIES%.*})"

echo -n "-----> Unpacking R $R_VERSION tarball...."
echo
tar -xf "$(basename ${R_BINARIES%.*})" -C $BUILD_DIR && rm -rf "$(basename ${R_BINARIES%.*})"

mkdir -p $TMP_APP_DIR
deep-mv $APP_DIR $TMP_APP_DIR

# Copy Application code in.
deep-mv $BUILD_DIR $APP_DIR

# Set new context.
ORIG_BUILD_DIR=$BUILD_DIR
BUILD_DIR=$APP_DIR

# export environment variables	
export BUILD_DIR CACHE_DIR ENV_DIR	
export PATH="$BUILD_DIR/.heroku/r/usr/bin/R/bin:$BUILD_DIR/.heroku/r/usr/bin:$BUILD_DIR/.heroku/r/usr/local/bin:$PATH"	
export LD_LIBRARY_PATH="$BUILD_DIR/.heroku/r/usr/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:$BUILD_DIR/.heroku/r/usr/lib:/lib"
export PKG_CONFIG_PATH="$BUILD_DIR/.heroku/r/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig"	
export CXX=g++	
export CXX11=g++	
export CC=gcc	
export FC=gfortran	
export F77=gfortran	

#export LDFLAGS="L/app/.heroku/r/usr/lib/x86_64-linux-gnu/libgfortran -lgfortran"	
export LIBRARY_PATH="$BUILD_DIR/.heroku/r/usr/lib:/app/.heroku/r/usr/lib/x86_64-linux-gnu"

# Switch to the repo's context.
cd $BUILD_DIR

mkdir -p $CACHE_DIR

# Restore old artifacts from the cache.
for dir in $CACHED_DIRS; do
  cp -R $CACHE_DIR/$dir . &> /dev/null || true
done

if [[ -f "$BUILD_DIR/Aptfile" ]]; then
  APTPATH="$BUILD_DIR/Aptfile"
elif [[ -f "$BUILD_DIR/apt-packages" ]]; then
  APTPATH="$BUILD_DIR/apt-packages" 
else
  APTPATH=""
fi

# get the init.r file to use
# it can be init.[rR] or run.R
if [[ -f "$BUILD_DIR/init.r" ]]; then
  INIT_FILE="$BUILD_DIR/init.r"
elif [[ -f "$BUILD_DIR/init.R" ]]; then
  INIT_FILE="$BUILD_DIR/init.R"
else
  # assuming run.R is present
  unset INIT_FILE
fi

if [[ ! -z "$INIT_FILE" ]]; then

  # prepare wrapper script
  WRAPPER="$BUILD_DIR/wrapper.R"
  cp "$BUILDPACK_DIR/bin/wrapper.R" $WRAPPER

  # perform insertions
  #  would have preferred to use sed or awk for this, but it's real tricky with multi-line
  #  replacements, so using a Ruby program, as Ruby is installed on Heroku by default
  ruby "$BUILDPACK_DIR/bin/util.rb" "$WRAPPER" "$INIT_FILE" "$BUILD_DIR" "$CRAN_MIRROR"

  env
  
  # execute the init.R 
  # working directory must be /app so that provided packages/scripts can be found
  $BUILD_DIR/.heroku/r/usr/bin/R/bin/R --no-init-file --no-save --quiet --slave --file=$WRAPPER 2>&1 | indent

  # determine whether the R script failed
  if [[ -f "$BUILD_DIR/status" ]]; then
    echo "R $R_VERSION successfully installed (with init)" | indent
  else
    echo -e "\033[1;31mERROR: R $R_VERSION failed while executing \"init\". Check the log for details.\033[0m" | indent
    exit 1
  fi

  # clean up
  rm "$BUILD_DIR/status" "$WRAPPER"

else

  echo "R $R_VERSION successfully installed" | indent

fi

cd $BUILD_DIR
mkdir -p $BUILD_DIR/.profile.d
echo 'export PATH="$PATH:$HOME/.heroku/r/usr/bin/R/bin:$HOME/.heroku/r/usr/bin/R/bin"' >> "${BUILD_DIR}/.profile.d/setvars.sh"
echo 'export PKG_CONFIG_PATH="$HOME/.heroku/r/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig"' >> "${BUILD_DIR}/.profile.d/setvars.sh"
echo 'export LD_LIBRARY_PATH="$HOME/.heroku/r/usr/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:$HOME/.heroku/r/usr/lib:/lib"' >> "${BUILD_DIR}/.profile.d/setvars.sh"
echo 'export LIBRARY_PATH="$HOME/.heroku/r/usr/lib:/app/.heroku/r/usr/lib/x86_64-linux-gnu"' >> "${BUILD_DIR}/.profile.d/setvars.sh"
echo 'export CC=gcc' >> "${BUILD_DIR}/.profile.d/setvars.sh"
echo 'export CXX=g++' >> "${BUILD_DIR}/.profile.d/setvars.sh"
echo 'export CXX11=g++' >> "${BUILD_DIR}/.profile.d/setvars.sh"
echo 'export FC=gfortran' >> "${BUILD_DIR}/.profile.d/setvars.sh"
echo 'export LDFLAGS="-lgfortran"' >> "${BUILD_DIR}/.profile.d/setvars.sh"

# Store new artifacts in cache.
for dir in $CACHED_DIRS; do
  rm -rf $CACHE_DIR/$dir
  cp -R $dir $CACHE_DIR/
done

# Copy Application code in.
deep-mv $BUILD_DIR $ORIG_BUILD_DIR
deep-mv $TMP_APP_DIR $APP_DIR

echo "-----> Done" | indent
echo

# debug
END_TIME="$(date -u +%s)"
ELAPSED="$(($END_TIME-$START_TIME))"
echo "Build took $ELAPSED seconds to complete" | indent
